%{

#define YY_NO_INPUT 1
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdocumentation"

#import "y.tab.h"
#import "ParseTree.h"

void yyerror(char *s);
%}

%option nounput
%x INCLUDEFILE

%%
(([0-9]+|([0-9]+)?\.[0-9]+|[0-9]+\.)[eE][+-]?[0-9]+)|(([0-9]+)?\.[0-9]+|[0-9]+\.) {
    double f = atof(yytext);
    yylval.fvalue = f;
    return REAL;
}

[1-9]+[0-9]*|0 {
    int i = atoi(yytext);
    yylval.ivalue = i;
    return NNINTEGER;
}

pi {
    yylval.svalue = [ParseTree addString:yytext];
    return PI;
}

sin {
    yylval.svalue = [ParseTree addString:yytext];
    return SIN;
}

cos {
    yylval.svalue = [ParseTree addString:yytext];
    return COS;
}

tan {
    yylval.svalue = [ParseTree addString:yytext];
    return TAN;
}

exp {
    yylval.svalue = [ParseTree addString:yytext];
    return EXP;
}

ln {
    yylval.svalue = [ParseTree addString:yytext];
    return LN;
}

sqrt {
    yylval.svalue = [ParseTree addString:yytext];
    return SQRT;
}

qreg {
    yylval.svalue = [ParseTree addString:yytext];
    return QREG;
}

creg {
    yylval.svalue = [ParseTree addString:yytext];
    return CREG;
}

gate {
    yylval.svalue = [ParseTree addString:yytext];
    return GATE;
}

measure {
    yylval.svalue = [ParseTree addString:yytext];
    return MEASURE;
}

if {
    yylval.svalue = [ParseTree addString:yytext];
    return IF;
}

reset {
    yylval.svalue = [ParseTree addString:yytext];
    return RESET;
}

barrier {
    yylval.svalue = [ParseTree addString:yytext];
    return BARRIER;
}

opaque {
    yylval.svalue = [ParseTree addString:yytext];
    return OPAQUE;
}

\"([^\\\"]|\\.)*\" { 
    yylval.svalue = [ParseTree addString:yytext];
    return STRING;
}

include {
    BEGIN INCLUDEFILE;
}

<INCLUDEFILE>[ \t]*      /* eat the whitespace */
<INCLUDEFILE>[^ \t]+; {
    const char* includePath = [ParseTree getIncludePath: yytext];
    yyin = fopen(includePath, "r" );
    
    if ( ! yyin ) {
        yyterminate();
    }
    yypush_buffer_state(yy_create_buffer( yyin, YY_BUF_SIZE ));
    yylineno = 1;
    BEGIN(INITIAL);
}

<INCLUDEFILE>.|\n {
    fprintf(stderr, "%4d bad include line\n", yylineno);
    yyterminate();
}


<<EOF>> {
    yypop_buffer_state();
    if ( !YY_CURRENT_BUFFER ) {
        yyterminate();
    }
}

\n { yylineno++; }

OPENQASM {
    yylval.svalue = [ParseTree addString:yytext];
    return OPENQASM;
}

"//".*  {
}

CX {
    yylval.svalue = [ParseTree addString:yytext];
    return CX;
}

U {
    yylval.svalue = [ParseTree addString:yytext];
    return U;
}

-> {
    yylval.svalue = [ParseTree addString:yytext];
    return ASSIGN;
}

== {
    yylval.svalue = [ParseTree addString:yytext];
    return MATCHES;
}


[a-z][a-zA-Z0-9_]* {
    yylval.svalue = [ParseTree addString:yytext];
    return ID;
}

[ \t\r] {
}

. {
    return yytext[0];
}

%%

int yywrap()
{
    return 1;
}

void yyerror(char *s)
{
    [ParseTree fail:yylineno msg:s];
}

#pragma clang diagnostic pop
